# 객체 지향과 디자인 패턴
## 프록시 패턴
- 프록시 패턴은 실제 객체를 대신하는 프록시 객체를 사용해서 `실제 객체의 생성이나 접근` 등을 제어할 수 있도록 하는 디자인 패턴
- 프록시는 대리인이라는 뜻으로, 무엇인가를 대신 처리하는 의미
- 일종의 비서라고 생각하면 이해하기 쉬우며, 사장님한테 사소한 질문을 하기보다는 비서한테 먼저 물어보는 개념이라고 생각할 수 있음

### 사용하는 이유
- 해당 객체가 메모리에 존재하지 않아도 기본적인 정보를 참조하거나 설정할 수 있고 또한 실제 객체의 기능이 `반드시 필요한 시점까지 객체의 생성을 미룰 수 있다.`
- 앱을 실행할 때 일부 제품 목록을 보여주는 화면이 있고, 이용자가 스크롤을 다운할 때 더 많은 제품 목록을 보여주는 화면이 있다고 가정
  - 이 때 앱이 실행되면서 제품과 관련된 모든 이미지가 화면에 로딩된다면, 이용자가 스크롤 다운하지 않아 제품과 관련된 이미지를 볼 수 없음에도 불구하고 이미지를 로딩하여 불필요하게 메모리를 사용할 수 있다
  - 그래서 이용자가 스크롤 다운하면서 화면에 보이는 이미지를 로딩하면 메모리를 효율적으로 이용할 수 있다.
- 쉽게 말해, 리소스가 큰 객체(이미지 등)를 미리 생성하기 보다는 필요할 때(이용자가 실제로 해당 제품을 볼 때) 생성하기 위해 사용한다

### 예제
![1](https://user-images.githubusercontent.com/95393311/158027314-8dfb7330-1867-483e-b32b-95fbfdbca977.JPG)

```
class ProxyImage(val path: String) : Image {
    val image: RealImage? = null
    
    override fun draw() {
        if (image == null) {
            image = RealImage(path) // 최초 접근 시 객체 생성
        }
        image.draw() // RealImage 객체에 위임
    }
}


fun onScroll(start: Int, end: Int) {
    //스크롤 시, 화면에 표시되는 이미지를 표시
    for (i in start..end) {
        val image = images.get(i)
        image.draw()
    }
}
```
![2](https://user-images.githubusercontent.com/95393311/158027537-ab1b07d0-db19-4973-b6bd-96d26bd9e824.jpg)
- ProxyImage 객체는 draw() 메서드가 처음 실행될 때, RealImage 객체를 생성하기 때문에 그 이전에는 RealImage 객체가 생성되지 않으므로 메모리에 이미지를 로딩하지 않는다.
- 따라서, 불필요한 메모리 사용을 방지할 수 있다
- 이미지 로딩 정책이 변경되더라도 ListUI에는 영향을 끼치지 않는다

### 프록시 종류
1. 가상 프록시 : 필요한 순간에 실제 객체를 생성해 주는 프록시
2. 원격 프록시 : 다른 프로세스에 존재하는 객체에 접근할 때 사용되는 프록시
3. 보호 프록시 : 실체 객체에 대한 접근을 제어하는 프록시이며, 접근 권한이 있는 경우에만 실제 객체의 메서드를 실행하는 방식으로 구현
   - 보호 프록시는 보호 프록시 객체를 생성할 때, 실제 객체를 전달한다. 따라서 상속을 통해서도 프록시를 구현할 수 있다

### 데코레이터 패턴과의 차이
- 데코레이터 패턴은 기존 객체의 기능을 확장하는데 의의
- 프록시 패턴은 실제 객채에 대한 접근을 제어하는데 의의

#### 참고한 블로그
[참고](https://coding-factory.tistory.com/711)

---

## 어댑터 패턴
- 클라이언트가 요구하는 인터페이스와 재사용하려는 모듈의 인터페이스가 일치하지 않을 때 사용할 수 있는 디자인 패턴
- 110V의 가전 제품을 220V 플러그에서는 사용하지 못하지만, 돼지코(어댑터)를 쓴다면 110V 가전제품 -> 돼지코 -> 220V 플러그에서 사용할 수 있다
- 또한, 클라이언트가 요구하는 인터페이스나 모듈의 인터페이스가 변경되더라도 어댑터가 변경의 여파를 막기 때문에 개방 폐쇄 원칙을 따를 수 있도록 도와줌

#### 예제
![3](https://user-images.githubusercontent.com/95393311/158028491-66e52288-af20-4b60-a576-99bd814527ad.jpg)
- 또 다른 예로는 SLF4J라는 로깅 API로, 동일 API로 여러 로깅 프레임워크를 사용할 수 있도록 어댑터 패턴을 사용하고 있다.

### 상속을 통한 구현
- 클래스 멤버로 어댑티를 생성하는 것이 아니라, 어댑티를 상속하는 방법
- 조립하는 방식과 유사하며, super 키워드를 통해 이용하고 싶은 어댑티의 메서드를 활용
- 하지만 클라이언트가 요구하는 인터페이스가 인터페이스가 아니라 추상 클래스면 자바와 코틀린에서는 다중 상속이 불가하기 때문에 제약이 발생

---

## 옵저버 패턴
- 한 객체의 상태 변화를 정해지지 않은 여러 다른 객체에게 통지하고 싶을 때 사용되는 디자인 패턴

### 옵저버 패턴을 이루는 객체 구성
1. 주제 객체(subject)
   1. 옵저버(관찰자) 목록을 관리하는 객체. 옵저버를 추가하거나 제거할 수 있음
      1. 옵저버 객체는 추상 클래스이기 때문에 이후에 다른 옵저버 구현 클래스가 생기더라도 주제 클래스는 변경되지 않는다
   2. 상태가 변경되면(=이벤트가 발생되면) 등록된 옵저버에게 이를 알린다
2. 옵저버 객체(observer)
   1. 주제 객체(관찰 대상)에서 상태가 변경되었다는 알림(=이벤트가 발생)을 받으면 특정 기능을 수행


### 구현 방법
![6](https://user-images.githubusercontent.com/95393311/158030843-89a5b7ae-5101-4245-8434-12ec210fa5ea.jpg)
- 옵저버들은 리스너이기 때문에 타입이 옵저버여야 한다. 그래서 옵저버 인터페이스를 상속
- 주제 객체는 관찰자를 알아야 통지할 수 있으니 클래스 멤버로 생성해야 한다

#### 옵저버 객체에게 상태 전달 방법
- 일반적으로는 주제 객체에서 옵저버 객체에 상태 값을 전달
- 하지만 경우에 따라서는 옵저버 객체가 주체 클래스에 대한 의존을 갖을 수도 있다
#### 옵저버에서 주제 객체 구분
- 하나의 옵저버 객체를 여러 주제 객체에 등록할 수 있다
  - 안드로이드 
    - MyActivity가 View.OnClickListener를 상속하여 옵저버 객체가 됨
    - 두 개의 Button 객체(두 개의 주제 객체)가 `setOnClickListener`(add와 동일) 를 통해 MyActivity를 옵저버 객체로 등록함
    - MyActivity 내에 `onClick(View v)` 메서드를 오버라이드하여 주제 객체가 통지했을 때, 특정 기능을 수행
    - 주제 객체가 여러 개이기 때문에 이를 구분할 수 있는 방법(id 또는 == 연산자)도 함께 생각해야 함
- 하나의 주제 객체에 다양한 옵저버 객체가 있을 수도 있다
  - 이를 위해 다양한 옵저버 객체를 관리 및 통지하는 기능을 가진 추상 클래스를 사용 

#### 옵저버 패턴 구현의 고려 사항
1. 주제 객체의 통지 기능 실행 주체
   1. 주제 객체가 직접 통지
      - 주제 객체의 상태가 바뀔 때마다 옵저버에게 통지할 때 유리
      - 왜냐? 개발자의 실수를 방지하기 위해
   2. 주제 객체의 상태를 변경하는 코드에서 통지
      - 한 개 이상의 주제 객체의 연속적인 상태 변경 이후에 옵저버에게 통지할 때 유리
      - 왜냐? 통지 시점을 관리하기 쉬워지므로
2. 옵저버 인터페이스의 분리
    - 한 주제 객체가 통지할 수 있는 상태 변경 내역의 종류가 다양한 경우(=발생되는 이벤트의 종류가 많은 경우) 각 종료 별로 인터페이스를 구현하는 것이 좋다.
      - 안드로이드에서 Touch 이벤트, Click 이벤트 등
    - 만약 한 인터페이스에서 모든 이벤트를 구현한다면, 구현 클래스에서 불필요한 이벤트의 코드도 같이 작성해야 한다
    - 또한, 각 이벤트가 강하게 연결될 가능성이 높아져 향후 특정 이벤트를 제거하거나 새로운 이벤트를 추가하기 어려워진다.
3. 통지 시점에서의 주제 객체 상태
    - 통지 시점에서 주제 객체의 상태에 결함이 없어야 한다
      - 통지하고 난 다음에 상태가 변경되지 않아야 한다
      - 템플릿 메서드 패턴을 활용하면 통지 시점에서 최신의 상태를 전달할 수 있다
4. 옵저버 객체의 실행 제약 조건
   - 옵저버 객체의 실행에 대한 제약 조건을 정해야 한다
     - 만약 이벤트가 발생하고 이를 여러 옵저버에게 통지하고 싶지만 처음 옵저버 클래스가 통지받고 특정 기능을 10분 이상 수행하고 있다면?
       - 그 다음 옵저버 객체에게 통지하는 게 지연됨
     - 정해진 시간 내에 응답하지 않을 경우 비동기 작업을 수행하거나 작업을 종료시킬 수 있도록 하는 등 제약 조건을 추가해야 함
       - 안드로이드에서는 특정 이벤트에 대해 5초 이상 응답하지 않으면 이용자에게 프로그램 종료 여부를 확인함

#### 추천 참고 사이트
- [옵저버패턴 떠먹여드립니다](https://velog.io/@haero_kim/%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4-%EA%B0%9C%EB%85%90-%EB%96%A0%EB%A8%B9%EC%97%AC%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4)
- [디모의 옵저버패턴](https://www.youtube.com/watch?v=GxZWb5Whq7w)

---

## 미디에이터 패턴
- 각 객체들이 직접 메시지를 주고 받는 대신, 중간에 중계 역할을 수행하는 미디에이터 객체를 두고 미디에이터를 통해서 각 객체들이 간접적으로 메시지를 주고 받도록 하는 디자인 패턴  
  (MVP 모델에서 Presenter와 비슷할지도?)
### 사용하는 이유
- 객체 간의 직접적인 의존이 많으면(서로 직접 메시지를 전달하면), 개별 클래스의 사용이 어려워지고, 메시지 흐름을 변경하면 관련된 클래스들도 모두 변경해야 하는 문제가 발생
- 따라서 객체들의 의존을 미디에이터 객체에 집중하여, 각 객체 간의 의존을 줄여 재사용성이 높아지고 수정 및 확장이 용이해진다.
- 미디에이터 클래스를 추상화하여 재사용성을 높일 수 있다.
  - 협업 객체 간의 동일한 메시지 흐름이 서로 다른 기능에서 반복될 경우, 추상 미디에이터 클래스를 이용하자

### 예제
> 객체 간의 직접적인 의존이 발생
![4](https://user-images.githubusercontent.com/95393311/158029418-d635ae1e-b2e1-4fd4-81ef-3c0c70f4d6c9.jpg)
> 미디에이터 객체를 통해 의존을 분산
![5](https://user-images.githubusercontent.com/95393311/158029420-f173946b-1a66-4c87-affa-078bdb127175.jpg)

- `MediaController` 이나 `VideoPlayer` 처럼 개별 객체의 재사용성을 높이고 싶다면 `옵저버 패턴`을 통해 미디에이터 객체의 의존도를 낮출 수 있다

### 단점
- 협업 클래스의 개수가 증가할수록 미디에이터의 코드는 복잡해지기 때문에, 미디에이터 객체를 유지 보수하는 것이 상대적으로 어려워진다.